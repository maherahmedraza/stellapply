// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resumes.sql

package persistence

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResume = `-- name: CreateResume :one
INSERT INTO resumes (
    user_id,
    name,
    template_id,
    content,
    is_primary
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, name, template_id, content, pdf_url, docx_url, ats_score, analysis_results, analyzed_at, is_primary, version, created_at, updated_at
`

type CreateResumeParams struct {
	UserID     pgtype.UUID `db:"user_id" json:"user_id"`
	Name       string      `db:"name" json:"name"`
	TemplateID string      `db:"template_id" json:"template_id"`
	Content    []byte      `db:"content" json:"content"`
	IsPrimary  pgtype.Bool `db:"is_primary" json:"is_primary"`
}

func (q *Queries) CreateResume(ctx context.Context, arg CreateResumeParams) (Resume, error) {
	row := q.db.QueryRow(ctx, createResume,
		arg.UserID,
		arg.Name,
		arg.TemplateID,
		arg.Content,
		arg.IsPrimary,
	)
	var i Resume
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TemplateID,
		&i.Content,
		&i.PdfUrl,
		&i.DocxUrl,
		&i.AtsScore,
		&i.AnalysisResults,
		&i.AnalyzedAt,
		&i.IsPrimary,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteResume = `-- name: DeleteResume :exec
DELETE FROM resumes
WHERE id = $1
`

func (q *Queries) DeleteResume(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteResume, id)
	return err
}

const getResumeByID = `-- name: GetResumeByID :one
SELECT id, user_id, name, template_id, content, pdf_url, docx_url, ats_score, analysis_results, analyzed_at, is_primary, version, created_at, updated_at FROM resumes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetResumeByID(ctx context.Context, id pgtype.UUID) (Resume, error) {
	row := q.db.QueryRow(ctx, getResumeByID, id)
	var i Resume
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TemplateID,
		&i.Content,
		&i.PdfUrl,
		&i.DocxUrl,
		&i.AtsScore,
		&i.AnalysisResults,
		&i.AnalyzedAt,
		&i.IsPrimary,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listResumesByUserID = `-- name: ListResumesByUserID :many
SELECT id, user_id, name, template_id, content, pdf_url, docx_url, ats_score, analysis_results, analyzed_at, is_primary, version, created_at, updated_at FROM resumes
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListResumesByUserID(ctx context.Context, userID pgtype.UUID) ([]Resume, error) {
	rows, err := q.db.Query(ctx, listResumesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Resume
	for rows.Next() {
		var i Resume
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.TemplateID,
			&i.Content,
			&i.PdfUrl,
			&i.DocxUrl,
			&i.AtsScore,
			&i.AnalysisResults,
			&i.AnalyzedAt,
			&i.IsPrimary,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResume = `-- name: UpdateResume :one
UPDATE resumes
SET
    name = COALESCE($2, name),
    template_id = COALESCE($3, template_id),
    content = COALESCE($4, content),
    is_primary = COALESCE($5, is_primary),
    ats_score = COALESCE($6, ats_score),
    analysis_results = COALESCE($7, analysis_results),
    analyzed_at = COALESCE($8, analyzed_at),
    updated_at = NOW(),
    version = version + 1
WHERE id = $1
RETURNING id, user_id, name, template_id, content, pdf_url, docx_url, ats_score, analysis_results, analyzed_at, is_primary, version, created_at, updated_at
`

type UpdateResumeParams struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	Name            string             `db:"name" json:"name"`
	TemplateID      string             `db:"template_id" json:"template_id"`
	Content         []byte             `db:"content" json:"content"`
	IsPrimary       pgtype.Bool        `db:"is_primary" json:"is_primary"`
	AtsScore        pgtype.Int4        `db:"ats_score" json:"ats_score"`
	AnalysisResults []byte             `db:"analysis_results" json:"analysis_results"`
	AnalyzedAt      pgtype.Timestamptz `db:"analyzed_at" json:"analyzed_at"`
}

func (q *Queries) UpdateResume(ctx context.Context, arg UpdateResumeParams) (Resume, error) {
	row := q.db.QueryRow(ctx, updateResume,
		arg.ID,
		arg.Name,
		arg.TemplateID,
		arg.Content,
		arg.IsPrimary,
		arg.AtsScore,
		arg.AnalysisResults,
		arg.AnalyzedAt,
	)
	var i Resume
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TemplateID,
		&i.Content,
		&i.PdfUrl,
		&i.DocxUrl,
		&i.AtsScore,
		&i.AnalysisResults,
		&i.AnalyzedAt,
		&i.IsPrimary,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
