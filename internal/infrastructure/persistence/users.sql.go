// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package persistence

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one
SELECT count(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email_encrypted,
    email_hash,
    password_hash,
    status,
    governance_metadata
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, external_id, email_encrypted, email_hash, phone_encrypted, password_hash, mfa_enabled, mfa_secret_encrypted, status, email_verified, email_verified_at, subscription_tier, subscription_expires_at, created_at, updated_at, deleted_at, last_login_at, data_region, governance_metadata
`

type CreateUserParams struct {
	EmailEncrypted     []byte      `db:"email_encrypted" json:"email_encrypted"`
	EmailHash          string      `db:"email_hash" json:"email_hash"`
	PasswordHash       string      `db:"password_hash" json:"password_hash"`
	Status             pgtype.Text `db:"status" json:"status"`
	GovernanceMetadata []byte      `db:"governance_metadata" json:"governance_metadata"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.EmailEncrypted,
		arg.EmailHash,
		arg.PasswordHash,
		arg.Status,
		arg.GovernanceMetadata,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.EmailEncrypted,
		&i.EmailHash,
		&i.PhoneEncrypted,
		&i.PasswordHash,
		&i.MfaEnabled,
		&i.MfaSecretEncrypted,
		&i.Status,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.SubscriptionTier,
		&i.SubscriptionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLoginAt,
		&i.DataRegion,
		&i.GovernanceMetadata,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUserByEmailHash = `-- name: GetUserByEmailHash :one
SELECT id, external_id, email_encrypted, email_hash, phone_encrypted, password_hash, mfa_enabled, mfa_secret_encrypted, status, email_verified, email_verified_at, subscription_tier, subscription_expires_at, created_at, updated_at, deleted_at, last_login_at, data_region, governance_metadata FROM users
WHERE email_hash = $1 LIMIT 1
`

func (q *Queries) GetUserByEmailHash(ctx context.Context, emailHash string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailHash, emailHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.EmailEncrypted,
		&i.EmailHash,
		&i.PhoneEncrypted,
		&i.PasswordHash,
		&i.MfaEnabled,
		&i.MfaSecretEncrypted,
		&i.Status,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.SubscriptionTier,
		&i.SubscriptionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLoginAt,
		&i.DataRegion,
		&i.GovernanceMetadata,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, external_id, email_encrypted, email_hash, phone_encrypted, password_hash, mfa_enabled, mfa_secret_encrypted, status, email_verified, email_verified_at, subscription_tier, subscription_expires_at, created_at, updated_at, deleted_at, last_login_at, data_region, governance_metadata FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.EmailEncrypted,
		&i.EmailHash,
		&i.PhoneEncrypted,
		&i.PasswordHash,
		&i.MfaEnabled,
		&i.MfaSecretEncrypted,
		&i.Status,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.SubscriptionTier,
		&i.SubscriptionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLoginAt,
		&i.DataRegion,
		&i.GovernanceMetadata,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET 
    email_hash = $2,
    email_encrypted = $3,
    status = $4,
    governance_metadata = $5,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID                 pgtype.UUID `db:"id" json:"id"`
	EmailHash          string      `db:"email_hash" json:"email_hash"`
	EmailEncrypted     []byte      `db:"email_encrypted" json:"email_encrypted"`
	Status             pgtype.Text `db:"status" json:"status"`
	GovernanceMetadata []byte      `db:"governance_metadata" json:"governance_metadata"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.EmailHash,
		arg.EmailEncrypted,
		arg.Status,
		arg.GovernanceMetadata,
	)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE users
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserStatusParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	Status pgtype.Text `db:"status" json:"status"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserStatus, arg.ID, arg.Status)
	return err
}
