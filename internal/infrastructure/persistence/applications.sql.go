// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applications.sql

package persistence

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    user_id, job_id, resume_id, resume_snapshot, cover_letter_id,
    cover_letter_snapshot, answers, status, submission_mode,
    submitted_at, submission_screenshot_url, error_message,
    retry_count, timeline
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, user_id, job_id, resume_id, resume_snapshot, cover_letter_id, cover_letter_snapshot, answers, status, submission_mode, submitted_at, submission_screenshot_url, error_message, retry_count, timeline, created_at, updated_at
`

type CreateApplicationParams struct {
	UserID                  pgtype.UUID        `db:"user_id" json:"user_id"`
	JobID                   pgtype.UUID        `db:"job_id" json:"job_id"`
	ResumeID                pgtype.UUID        `db:"resume_id" json:"resume_id"`
	ResumeSnapshot          []byte             `db:"resume_snapshot" json:"resume_snapshot"`
	CoverLetterID           pgtype.UUID        `db:"cover_letter_id" json:"cover_letter_id"`
	CoverLetterSnapshot     pgtype.Text        `db:"cover_letter_snapshot" json:"cover_letter_snapshot"`
	Answers                 []byte             `db:"answers" json:"answers"`
	Status                  pgtype.Text        `db:"status" json:"status"`
	SubmissionMode          pgtype.Text        `db:"submission_mode" json:"submission_mode"`
	SubmittedAt             pgtype.Timestamptz `db:"submitted_at" json:"submitted_at"`
	SubmissionScreenshotUrl pgtype.Text        `db:"submission_screenshot_url" json:"submission_screenshot_url"`
	ErrorMessage            pgtype.Text        `db:"error_message" json:"error_message"`
	RetryCount              pgtype.Int4        `db:"retry_count" json:"retry_count"`
	Timeline                []byte             `db:"timeline" json:"timeline"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.UserID,
		arg.JobID,
		arg.ResumeID,
		arg.ResumeSnapshot,
		arg.CoverLetterID,
		arg.CoverLetterSnapshot,
		arg.Answers,
		arg.Status,
		arg.SubmissionMode,
		arg.SubmittedAt,
		arg.SubmissionScreenshotUrl,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.Timeline,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.ResumeID,
		&i.ResumeSnapshot,
		&i.CoverLetterID,
		&i.CoverLetterSnapshot,
		&i.Answers,
		&i.Status,
		&i.SubmissionMode,
		&i.SubmittedAt,
		&i.SubmissionScreenshotUrl,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.Timeline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications WHERE id = $1
`

func (q *Queries) DeleteApplication(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteApplication, id)
	return err
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT id, user_id, job_id, resume_id, resume_snapshot, cover_letter_id, cover_letter_snapshot, answers, status, submission_mode, submitted_at, submission_screenshot_url, error_message, retry_count, timeline, created_at, updated_at FROM applications WHERE id = $1
`

func (q *Queries) GetApplicationByID(ctx context.Context, id pgtype.UUID) (Application, error) {
	row := q.db.QueryRow(ctx, getApplicationByID, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.ResumeID,
		&i.ResumeSnapshot,
		&i.CoverLetterID,
		&i.CoverLetterSnapshot,
		&i.Answers,
		&i.Status,
		&i.SubmissionMode,
		&i.SubmittedAt,
		&i.SubmissionScreenshotUrl,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.Timeline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listApplicationsByUserID = `-- name: ListApplicationsByUserID :many
SELECT id, user_id, job_id, resume_id, resume_snapshot, cover_letter_id, cover_letter_snapshot, answers, status, submission_mode, submitted_at, submission_screenshot_url, error_message, retry_count, timeline, created_at, updated_at FROM applications WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListApplicationsByUserID(ctx context.Context, userID pgtype.UUID) ([]Application, error) {
	rows, err := q.db.Query(ctx, listApplicationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.JobID,
			&i.ResumeID,
			&i.ResumeSnapshot,
			&i.CoverLetterID,
			&i.CoverLetterSnapshot,
			&i.Answers,
			&i.Status,
			&i.SubmissionMode,
			&i.SubmittedAt,
			&i.SubmissionScreenshotUrl,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.Timeline,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications SET
    resume_id = $2,
    resume_snapshot = $3,
    cover_letter_id = $4,
    cover_letter_snapshot = $5,
    answers = $6,
    status = $7,
    submission_mode = $8,
    submitted_at = $9,
    submission_screenshot_url = $10,
    error_message = $11,
    retry_count = $12,
    timeline = $13,
    updated_at = NOW()
WHERE id = $1 RETURNING id, user_id, job_id, resume_id, resume_snapshot, cover_letter_id, cover_letter_snapshot, answers, status, submission_mode, submitted_at, submission_screenshot_url, error_message, retry_count, timeline, created_at, updated_at
`

type UpdateApplicationParams struct {
	ID                      pgtype.UUID        `db:"id" json:"id"`
	ResumeID                pgtype.UUID        `db:"resume_id" json:"resume_id"`
	ResumeSnapshot          []byte             `db:"resume_snapshot" json:"resume_snapshot"`
	CoverLetterID           pgtype.UUID        `db:"cover_letter_id" json:"cover_letter_id"`
	CoverLetterSnapshot     pgtype.Text        `db:"cover_letter_snapshot" json:"cover_letter_snapshot"`
	Answers                 []byte             `db:"answers" json:"answers"`
	Status                  pgtype.Text        `db:"status" json:"status"`
	SubmissionMode          pgtype.Text        `db:"submission_mode" json:"submission_mode"`
	SubmittedAt             pgtype.Timestamptz `db:"submitted_at" json:"submitted_at"`
	SubmissionScreenshotUrl pgtype.Text        `db:"submission_screenshot_url" json:"submission_screenshot_url"`
	ErrorMessage            pgtype.Text        `db:"error_message" json:"error_message"`
	RetryCount              pgtype.Int4        `db:"retry_count" json:"retry_count"`
	Timeline                []byte             `db:"timeline" json:"timeline"`
}

func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, updateApplication,
		arg.ID,
		arg.ResumeID,
		arg.ResumeSnapshot,
		arg.CoverLetterID,
		arg.CoverLetterSnapshot,
		arg.Answers,
		arg.Status,
		arg.SubmissionMode,
		arg.SubmittedAt,
		arg.SubmissionScreenshotUrl,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.Timeline,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.ResumeID,
		&i.ResumeSnapshot,
		&i.CoverLetterID,
		&i.CoverLetterSnapshot,
		&i.Answers,
		&i.Status,
		&i.SubmissionMode,
		&i.SubmittedAt,
		&i.SubmissionScreenshotUrl,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.Timeline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
